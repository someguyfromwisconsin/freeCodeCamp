<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Technical Guide</title>
</head>
<body>
    <main id="main-doc">
        <section class="main-section" id="scope">
            <header>Scope</header>
            <p>Scope refers to the context in which variables are declared and accessed. It defines the visibility and accessibility of variables in different parts of your code. JavaScript has two main types of scope: global scope and local scope.</p>
            <ul>
                <li>Global Scope:

                    Variables declared outside of any function or block have a global scope.
                    They can be accessed from any part of the code, including within functions.
                    Be cautious with global variables, as they can lead to naming conflicts and make it harder to manage your code.</li>
                    <code>var globalVariable = 10;

                        function exampleFunction() {
                            console.log(globalVariable); // Accessible
                        }
                        </code>
                <li>Local Scope:

                    Variables declared within a function or block have a local scope.
                    They are only accessible within the function or block where they are declared.
                    This helps encapsulate variables and avoids naming conflicts with variables in other parts of the code.</li>
                    <code>function exampleFunction() {
                        var localVariable = 20;
                        console.log(localVariable); // Accessible
                    
                        if (true) {
                            var anotherLocalVariable = 30;
                            console.log(anotherLocalVariable); // Accessible
                        }
                    }
                    
                    console.log(localVariable); // Error, not accessible outside the function
                    console.log(anotherLocalVariable); // Accessible, as it is declared with 'var'
                    </code>
            </ul>
        </section>
        <section class="main-section" id="ternary_operator">
            <header>The Ternary/Conditional Operator</header>
            <p>The ternary operator, also known as the conditional operator, is a concise way to write an if-else statement in a single line of code. It takes three operands and evaluates a condition. If the condition is true, it returns the value of the first operand; otherwise, it returns the value of the second operand. The general syntax is as follows:</p>
            <code>condition ? expressionIfTrue : expressionIfFalse;
            </code>
            <ul>
                <li>condition: This is the expression that is evaluated. If the condition is truthy, the expression before the : is executed; otherwise, the expression after the : is executed.</li>
                <li>expressionIfTrue: The value returned if the condition is true./li>
                <li>expressionIfFalse: The value returned if the condition is false.</li>
            </ul>
            <code>var isRaining = true;
                var weather = isRaining ? "Take an umbrella" : "Enjoy the sun";
                
                console.log(weather); // Output: "Take an umbrella"
                
            </code>
        </section>
        <section class="main-section" id="destructuring">
            <header>Destructuring</header>
            <p>Destructuring is a feature in JavaScript that allows you to extract values from arrays or properties from objects into distinct variables. It provides a concise and readable syntax for assigning values from arrays or objects to variables.</p>
            <ul>
                <li>Array Destructuring:</li>
                    <ul>
                        <li>
                            <code>// Basic Array Destructuring
                                const numbers = [1, 2, 3];
                                const [a, b, c] = numbers;
                                
                                console.log(a); // Output: 1
                                console.log(b); // Output: 2
                                console.log(c); // Output: 3
                            </code>
                        </li>
                        <li>You can also skip elements using commas:
                            <code>const [first, , third] = numbers;
                                console.log(first, third); // Output: 1 3
                            </code>
                        </li>
                        <li>Destructuring with the rest operator:
                            <code>const [first, ...rest] = numbers;
                                console.log(first); // Output: 1
                                console.log(rest);  // Output: [2, 3]
                            </code>
                        </li>
                    </ul>
                <li>Object Destructuring:</li>
                    <ul>
                        <li>
                            <code>// Basic Object Destructuring
                                const person = { name: "John", age: 30 };
                                const { name, age } = person;
                                
                                console.log(name); // Output: "John"
                                console.log(age);  // Output: 30
                            </code>
                        </li>
                        <li>Renaming variables during destructuring:
                            <code>const { name: personName, age: personAge } = person;
                                console.log(personName, personAge); // Output: "John" 30
                            </code>
                        </li>
                        <li>Destructuring with default values:
                            <code>const { name = "Anonymous", age = 25 } = person;
                                console.log(name, age); // Output: "John" 30 (if 'name' and 'age' are present in the 'person' object)
                            </code>
                        </li>
                        <li>Destructuring is commonly used in function parameters to extract values directly:
                            <code>function printPerson({ name, age }) {
                                console.log(`Name: ${name}, Age: ${age}`);
                              }
                              
                              printPerson(person); // Output: "Name: John, Age: 30"
                            </code>
                        </li>
                    </ul>
            </ul>
        </section>
        <section class="main-section" id="spread_operator">
            <header>The Spread Operator</header>
            <p>The spread operator (...) in JavaScript is a useful syntax for expanding elements of an iterable (like an array or a string) or properties of an object. It allows you to easily copy and combine arrays, create shallow clones of objects, and more. The spread syntax can be used in various contexts:</p>
            <ul>
                <li>Arrays</li>
                <ul>
                    <li>Copying an array:
                        <code>const originalArray = [1, 2, 3];
                            const copiedArray = [...originalArray];
                            
                            console.log(copiedArray); // Output: [1, 2, 3]
                        </code>
                    </li>
                    <li>Concatenating arrays:
                        <code>const array1 = [1, 2, 3];
                            const array2 = [4, 5, 6];
                            const combinedArray = [...array1, ...array2];
                            
                            console.log(combinedArray); // Output: [1, 2, 3, 4, 5, 6]
                        </code>
                    </li>
                </ul>
                <li>Objects</li>
                    <ul>
                        <li> Shallow cloning an object:
                            <code>const originalObject = { a: 1, b: 2 };
                                const clonedObject = { ...originalObject };
                                
                                console.log(clonedObject); // Output: { a: 1, b: 2 }
                            </code>
                        </li>
                        <li> Merging objects:
                            <code>const object1 = { a: 1, b: 2 };
                                const object2 = { b: 3, c: 4 };
                                const mergedObject = { ...object1, ...object2 };
                                
                                console.log(mergedObject); // Output: { a: 1, b: 3, c: 4 }
                            </code>
                        </li>
                    </ul>
                <li>Function Arguments</li>
                    <ul>
                        <li>Passing array elements as function arguments:
                            <code>const numbers = [1, 2, 3];

                                function add(a, b, c) {
                                  return a + b + c;
                                }
                                
                                const result = add(...numbers);
                                console.log(result); // Output: 6
                            </code>
                        </li>
                    </ul>
                <li>Strings</li>
                    <ul>
                        <li>Converting a string to an array of characters:
                            <code>const originalString = "hello";
                                const charArray = [...originalString];
                                
                                console.log(charArray); // Output: ['h', 'e', 'l', 'l', 'o']
                            </code>
                        </li>
                    </ul>
            </ul>
        </section>
        <section class="main-section" id="arrow_functions">
            <header>Arrow Functions</header>
            <p>Arrow functions provide a more concise syntax for writing function expressions in JavaScript. They offer a shorter syntax compared to traditional function expressions and do not bind their own <code>this</code>, <code>arguments</code>, <code>super</code>, or <code>new.target</code>. Arrow functions are often used for inline functions, especially when passing functions as arguments or when defining short, one-off functions.</p>
            <ul>
                <li>Basic Syntax:
                    <code>// Traditional function expression
                        const add = function (a, b) {
                          return a + b;
                        };
                        
                        // Arrow function
                        const addArrow = (a, b) => a + b;
                    </code>
                </li>
                <li>Handling Parameters:
                    <ul>
                        <li>If a function has a single parameter, you can omit the parentheses:
                            <code>const square = x => x * x;
                            </code>
                        </li>
                        <li>For functions with no parameters, you still need parentheses:
                            <code>const greet = () => console.log("Hello, world!");
                            </code>
                        </li>
                    </ul>
                </li>
                <li>Returning Objects:
                    <p>When returning an object literal, you need to wrap it in parentheses to avoid confusion with the function block:</p>
                    <code>const createPerson = (name, age) => ({ name: name, age: age });
                        // or
                        const createPersonShort = (name, age) => ({ name, age });
                        </code>
                </li>
                <li>Handling <code>this</code>:
                    <p>Arrow functions do not bind their own this value; instead, they inherit it from the enclosing scope. This behavior can be beneficial in certain situations, but it's important to be aware of the differences compared to traditional functions.</p>
                    <code>function Counter() {
                        this.count = 0;
                      
                        // Traditional function expression
                        setInterval(function () {
                          this.count++; // 'this' refers to the global object or undefined (in strict mode)
                          console.log(this.count);
                        }, 1000);
                      
                        // Arrow function (avoids the 'this' issue)
                        setInterval(() => {
                          this.count++;
                          console.log(this.count);
                        }, 1000);
                      }
                      
                      const counter = new Counter();
                      </code>
                </li>
            </ul>
        </section>
    </main>
</body>
</html>